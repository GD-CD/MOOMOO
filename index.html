<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>.io Game</title>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #222;
    }

    canvas {
      display: block;
      background: #3a7d3a;
    }

    #leaderboard {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.6);
      color: white;
      padding: 10px;
      font-family: monospace;
      font-size: 14px;
      min-width: 140px;
    }
  </style>
</head>

<body>
<div id="leaderboard"></div>
<canvas id="game"></canvas>

<script>
/* ================== CONFIG ================== */
const WORLD_SIZE = 5000;
const PLAYER_RADIUS = 20;

/* ================== CANVAS ================== */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

/* ================== NETWORK ================== */
const socket = new WebSocket("ws://localhost:8080");
const players = new Map();
let myId = null;

socket.onopen = () => console.log("WS CONNECTED");
socket.onerror = e => console.error("WS ERROR", e);
socket.onclose = () => console.log("WS CLOSED");

socket.onmessage = e => {
  console.log("WS MESSAGE:", e.data);

  const data = JSON.parse(e.data);

  if (data.type === "init") {
    myId = data.id;
    console.log("MY ID:", myId);
  }

  if (data.type === "state") {
    data.players.forEach(p => players.set(p.id, p));
  }
};


/* ================== INPUT ================== */
const keys = {};
const mouse = { x: 0, y: 0 };

window.addEventListener("keydown", e => keys[e.key] = true);
window.addEventListener("keyup", e => keys[e.key] = false);
canvas.addEventListener("mousemove", e => {
  mouse.x = e.clientX;
  mouse.y = e.clientY;
});

/* ================== CAMERA ================== */
function getCamera(player) {
  return {
    x: canvas.width / 2 - player.x,
    y: canvas.height / 2 - player.y
  };
}

/* ================== UPDATE ================== */
function update() {
  if (!players.has(myId)) return;

  const me = players.get(myId);
  const cam = getCamera(me);

  const worldMouseX = mouse.x - cam.x;
  const worldMouseY = mouse.y - cam.y;
  const angle = Math.atan2(worldMouseY - me.y, worldMouseX - me.x);

  socket.send(JSON.stringify({
    w: keys.w,
    a: keys.a,
    s: keys.s,
    d: keys.d,
    angle
  }));
}

/* ================== DRAW GRID ================== */
function drawGrid(cam) {
  const size = 100;
  ctx.strokeStyle = "#2f6f2f";

  for (let x = -WORLD_SIZE; x <= WORLD_SIZE; x += size) {
    ctx.beginPath();
    ctx.moveTo(x + cam.x, -WORLD_SIZE + cam.y);
    ctx.lineTo(x + cam.x, WORLD_SIZE + cam.y);
    ctx.stroke();
  }

  for (let y = -WORLD_SIZE; y <= WORLD_SIZE; y += size) {
    ctx.beginPath();
    ctx.moveTo(-WORLD_SIZE + cam.x, y + cam.y);
    ctx.lineTo(WORLD_SIZE + cam.x, y + cam.y);
    ctx.stroke();
  }
}

/* ================== DRAW PLAYER ================== */
function drawPlayer(p, cam) {
  const x = p.x + cam.x;
  const y = p.y + cam.y;

  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(p.angle);

  // Body (brown)
  ctx.beginPath();
  ctx.arc(0, 0, PLAYER_RADIUS, 0, Math.PI * 2);
  ctx.fillStyle = "#8b5a2b";
  ctx.fill();

  // Weapon (horizontal)
  ctx.fillStyle = "#654321";
  ctx.fillRect(PLAYER_RADIUS, -4, 30, 8);

  ctx.restore();
}

/* ================== LEADERBOARD ================== */
function drawLeaderboard() {
  const board = document.getElementById("leaderboard");
  board.innerHTML = "<b>Leaderboard</b><br>";

  players.forEach(p => {
    board.innerHTML += `Player ${p.id.slice(0,4)}<br>`;
  });
}

/* ================== MINIMAP ================== */
function drawMiniMap() {
  const size = 150;
  const padding = 10;
  const scale = size / (WORLD_SIZE * 2);

  const x = canvas.width - size - padding;
  const y = canvas.height - size - padding;

  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.fillRect(x, y, size, size);

  players.forEach(p => {
    const px = x + size / 2 + p.x * scale;
    const py = y + size / 2 + p.y * scale;

    ctx.fillStyle = p.id === myId ? "red" : "white";
    ctx.fillRect(px - 2, py - 2, 4, 4);
  });

  ctx.strokeStyle = "white";
  ctx.strokeRect(x, y, size, size);
}

/* ================== DRAW ================== */
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (!players.has(myId)) return;

  const cam = getCamera(players.get(myId));
  drawGrid(cam);

  players.forEach(p => drawPlayer(p, cam));

  drawLeaderboard();
  drawMiniMap();
}

/* ================== LOOP ================== */
function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>

